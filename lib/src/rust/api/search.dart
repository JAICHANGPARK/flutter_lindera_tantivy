// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            // These functions are ignored because they are not marked as `pub`: `generate_uuid`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `SearchIndex`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`


            /// 검색 인덱스를 초기화합니다
String  initializeSearchIndex() => RustLib.instance.api.crateApiSearchInitializeSearchIndex();

/// 디스크에 인덱스를 생성하거나 로드합니다
String  initializeSearchIndexWithPath({required String indexPath }) => RustLib.instance.api.crateApiSearchInitializeSearchIndexWithPath(indexPath: indexPath);

/// 샘플 문서를 인덱싱합니다
String  indexSampleDocuments() => RustLib.instance.api.crateApiSearchIndexSampleDocuments();

/// 문서를 검색합니다 (형태소 분석 + N-gram 부분 검색)
List<SearchResult>  searchDocuments({required String queryStr , required BigInt limit }) => RustLib.instance.api.crateApiSearchSearchDocuments(queryStr: queryStr, limit: limit);

/// 커스텀 문서를 추가합니다 (UUID 자동 생성)
String  addDocument({required String title , required String body , required String metadataJson }) => RustLib.instance.api.crateApiSearchAddDocument(title: title, body: body, metadataJson: metadataJson);

/// 여러 문서를 한 번에 추가합니다 (UUID 자동 생성)
String  addDocuments({required List<DocumentInput> documents }) => RustLib.instance.api.crateApiSearchAddDocuments(documents: documents);

/// 문서를 업데이트합니다 (ID로 찾아서 삭제 후 재추가)
String  updateDocument({required String id , required String title , required String body , required String metadataJson }) => RustLib.instance.api.crateApiSearchUpdateDocument(id: id, title: title, body: body, metadataJson: metadataJson);

/// ID로 문서를 삭제합니다
String  deleteDocument({required String id }) => RustLib.instance.api.crateApiSearchDeleteDocument(id: id);

/// 여러 문서를 한 번에 삭제합니다
String  deleteDocuments({required List<String> ids }) => RustLib.instance.api.crateApiSearchDeleteDocuments(ids: ids);

/// 모든 문서를 삭제합니다
String  clearAllDocuments() => RustLib.instance.api.crateApiSearchClearAllDocuments();

/// 인덱스에 있는 문서 개수를 반환합니다
BigInt  getDocumentCount() => RustLib.instance.api.crateApiSearchGetDocumentCount();

            class DocumentInput  {
                final String id;
final String title;
final String body;
final String metadata;

                const DocumentInput({required this.id ,required this.title ,required this.body ,required this.metadata ,});

                
                

                
        @override
        int get hashCode => id.hashCode^title.hashCode^body.hashCode^metadata.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is DocumentInput &&
                runtimeType == other.runtimeType
                && id == other.id&& title == other.title&& body == other.body&& metadata == other.metadata;
        
            }

class SearchResult  {
                final String id;
final String title;
final String body;
final double score;
final String metadata;

                const SearchResult({required this.id ,required this.title ,required this.body ,required this.score ,required this.metadata ,});

                
                

                
        @override
        int get hashCode => id.hashCode^title.hashCode^body.hashCode^score.hashCode^metadata.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is SearchResult &&
                runtimeType == other.runtimeType
                && id == other.id&& title == other.title&& body == other.body&& score == other.score&& metadata == other.metadata;
        
            }
            